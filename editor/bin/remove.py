#!/usr/bin/env python

import warnings
warnings.filterwarnings("ignore", category=FutureWarning, append=1)

import xmldns
import xmldns.validator
import sys
import getopt
import os
import re

# Really, this should have been a class with the state available as instance
# variables but I guess I am still thinking like a c programmer
def stateInit():
  ''' Initializes/returns the state object '''
  # doc_base = "../../res/db/"
  doc_base = "res/db/"
  listFactory = xmldns.ListFactory(doc_base)
  # print "Initializing host list from xml..."
  xmlHostList = listFactory.getXMLHostList()
  hostList    = listFactory.getHostListFromXML(xmlHostList)
  # print "Initializing network list from xml..."
  xmlNetworkList = listFactory.getXMLNetworkList()
  networkList    = listFactory.getNetworkListFromXML(xmlNetworkList)
  # print "Initializing domain list from xml..."
  xmlDomainList = listFactory.getXMLDomainList()
  domainList    = listFactory.getDomainListFromXML(xmlDomainList)
  state       = xmldns.ProgState(hostList, networkList, domainList)
  state.setListFactory( listFactory )
  return state

################################################################################
# Generic functions to make life easier ########################################
################################################################################

################################################################################
# Save all changes #############################################################
################################################################################
# TODO: print out log of all changes generated by user

def saveChanges(state):
  '''Save the state of the host list to the xml file'''
  state.appendLogLiteral("Saved changes")
  state.getListFactory().writeXMLHostList(state)

################################################################################
# The main loop ################################################################
################################################################################

def usage():
  print "Usage:"
  print "  " + sys.argv[0] + " --help"
  print "  " + sys.argv[0] + " [--domain domain.name.edu] hostname [hostname [...]]"

def getNetworkFromIP4(state, ip):

  # Make quad easy to work with
  prefixSplit = re.compile(r'^(\d+)\.(\d+)\.(\d+)\.(\d+)/(\d+)$')
  srcPieces = ip.split(".")
  srcNum = 0
  srcNum += int(srcPieces[0]) << 24
  srcNum += int(srcPieces[1]) << 16
  srcNum += int(srcPieces[2]) << 8
  srcNum += int(srcPieces[3])

  for network in state.getNetworkList().getList():
    for prefix in network.getRecordsOfType('prefix'):
      if re.match("^\d+\.\d+\.\d+\.\d+/\d+$", prefix.recordData):
        ipPieces = prefixSplit.search( prefix.recordData ).groups()
        prefixNum = 0
        prefixNum += int(ipPieces[0]) << 24
        prefixNum += int(ipPieces[1]) << 16
        prefixNum += int(ipPieces[2]) << 8
        prefixNum += int(ipPieces[3])
        prefixMask = 0;
        for i in range(int(ipPieces[4])):
          prefixMask = prefixMask << 1
          prefixMask = prefixMask + 1
        for i in range(32 - int(ipPieces[4])):
          prefixMask = prefixMask << 1
        # print "prefix/mask: %d/%d" % (prefixNum, prefixMask)
        tmp1 = srcNum & prefixMask
        tmp2 = prefixNum & prefixMask
        # If the IP is in the network prefix... return the network
        if tmp1 == tmp2:
          return network.name
  # if we did not find a network, return nothing
  return None

def main(argv):

  # Set default domain for LPL
  new_host_args = {
    'domain': 'lpl.arizona.edu'
    }

  try:
    opts, args = getopt.getopt(argv, "", ['help', 'domain='])
  except getopt.GetoptError:
    usage()
    sys.exit(2)

  p_opts = [e for e,trash in opts]
  if not '--help' in p_opts and len(args) < 1:
    usage()
    sys.exit(2)

  # Initialize state from XML Document
  state = stateInit()

  # Parse in some arguments to keep track of record types we are dealing with
  for opt, arg in opts:
    opt = re.sub('^[-]+', '', opt)
    if opt in ( 'hostname', 'domain', 'a', 'mx', 'description', 'macAddress' ):
      new_host_args[ opt ] = arg

  # filter our target list down ...
  domain_filter = lambda host, input_name: host.domainname == input_name
  preSearchedHostList = state.getHostList().filteredList(domain_filter,new_host_args[ 'domain' ])

  # Then look for an existing host entry that matches the same name
  host_filter = lambda host, input_name: host.shortname == input_name

  # hostnames to remove...
  for hostname in args:

    searchedHostList = preSearchedHostList.filteredList(host_filter, hostname)

    if len( searchedHostList.getList() ) == 0:
      print "Host does not exist."
    else:

      # If there are multiple hosts, take the first matching
      newHost = searchedHostList.getList()[0]

      # Set the current host
      state.setCurrentHost( newHost )

      # Show new host description
      print "Removing host:"
      state.getCurrentHost().printHost("| ")

      # remove current host
      state.appendLog("Removed entry")
      state.setCurrentHost(state.getHostList().removeHost(state.getCurrentHost()))

  # Done removing hosts from state...
  # Save the configuration
  saveChanges( state )

  # Print session log
  print "Session Log:"
  print state.getLog()
  print "--------------------------------------------------------------------------------"

## What to do if we are called directly as an editor
if __name__ == "__main__":
  main(sys.argv[1:])
  sys.exit(0)
